# Класс
[Prototype]: http://prototypejs.org
[Mootools]:  http://mootools.net
[Ruby]:      http://www.ruby-lang.org

RightJS - объектно-ориентированная библиотека, в следствии чего она 
предоставляет расширенные возможности для объектно-ориентированного 
программирования. Классы в RightJS представляют собой смесь идей из
библиотеки [Prototype][] и языка программирования [Ruby][].


## Базовое определение

Базовое определение класса в RightJS выглядит точно так же как оно выглядит
в библиотеках [Prototype][] и [Mootools][]

    var Klass = new Class({
      initialize: function() {
        // constructor
      },
      
      method1: function() {},
      method2: function() {}
    });


## Наследование

Наследование в RightJS выглядит похожим на наследование в библиотеке
[Prototype][], точно так же нужно передать два аргумента, базовый класс и
методы нового класса. Разница только в том, что в RightJS для обращения к
методам родительского класса используется переменная `this.$super`

    var Girl = new Class({
      sayHello: function() {
        return "Hello there";
      }
    });
    
    var SexyGirl = new Class(Girl, {
      sayHello: function() {
        return "Well "+ this.$super() + "!";
      }
    });


## Модули в стиле Ruby

Язык [Ruby][] использует преимущества множественного наследования путем
возможности создавать независимые библиотеки и далее вставлять их в тело
любого класса, позволяя тем самым совместное использование неограниченного
количества модулей несколькими классами.

Библиотека RightJS предоставляет ту же самую возможность в классах JavaScript

    var Module = {
      method: function() {}
    };
    
    var Klass = new Class({
      include: Module, // <- добавить модуль на уровень объекта
      extend:  Module, // <- добавить модуль на уровень класса
      
      // остальные методы класса
    });

Вы так же можете вставлять несколько модулей одновременно, с помощью списков

    var Klass = new Class({
      include: [Module1, Module2, ...],
      
      // или на уровне класса
      extend:  [Module1, Module2, ...]
    });

Можно так-же определять объекты непосредственно в теле класса, что позволяет
естественным образом описывать константы и методы уровня класса в одном куске
кода с методами уровня объекта

    var Klass = new Class({
      extend: {
        CLASS_LEVEL_CONST_1: 1,
        CLASS_LEVEL_CONST_2: 2,
        
        classLevelMethod: function() {}
      },
      
      // методы уровня объекта
    });

Вы так же можете вызывать методы `include()` и `extend()` после того как
класс был уже определен.

    var Klass = new Class({
      // ....
    });
    
    Klass.include(Module, Module, ...);
    Klass.extend(Module, Module, ...);
    
__ВНИМАНИЕ:__ приоритет вставляемых модулей в RightJS работает точно в том же
порядке, как это происходит в языке программирования [Ruby][]. Т.е. если вы
вставили модуль во время определения класса, то собственные методы класса
будут иметь приоритет над методами модуля. Но если вы вставляете модуль,
используя методы `include()` и `extend()` _после_ того как класс был 
инициализирован, то методы модулей будут установлены поверх методов класса.


## Обратные вызовы для модулей

Предоставляя похожую на [Ruby][] функциональность для работы с модулями,
RightJS предоставляет похожую возможность для обработки обратных вызовов
во время вставки модулей в классы. RightJS сохраняет имена похожими на
условные имена в [Ruby][]: `selfIncluded` и `selfExtended`. Или в случае
использования стиля с подчеркиваниями `self_included` и `self_extened`

    var Module = {
      selfIncluded: function(klass) {
        klass.prototype.foo = 'bar';
      },
      
      selfExtended: function(klass) {
        klass.FOO = 'BAR';
      }
    };
    
    var Klass = new Class({
      include: Module,
      extend:  Module
    });
    
    Klass.prototype.foo; // -> 'bar'
    Klass.FOO;           // -> 'BAR'


Вы можете так же заглянуть в специальную
[статью по ООП](/tutorials/object-oriented-programming) с более детальными
описаниями процессов.
